\section{Converting Solutions of Quadratic Models}

\subsection{Choosing Power Levels}
\label{implementation:quantum.read.solution.qubo}

For QUBOs, it can happen that for a single power plant at a single time instance, multiple binary variables for different power levels are $1$.
The program then has to choose one of the possible power levels where the binary variable is $1$.
Listing \ref{implementation:quantum.read.solution.qubo.algorithm} shows the code that is used to choose one power level.
The program always chooses the median value.

\begin{python}[
  float,
  caption={Choosing Power Levels from the QUBO},
  label={implementation:quantum.read.solution.qubo.algorithm}
]
# store every power level k possible at time t for plant i
value_indices: List[int] = []
for k in range(len(self.P[i])):
  if result[self.m[i, t, k]] == 1:
    value_indices.append(k)

value: float = 0
num_indices: int = len(value_indices)
if num_indices > 0:
  # choose median power level
  value = self.P[i][value_indices[(int) (num_indices / 2)]]
  if num_indices > 1:
    debug_msg('Warning: {} possible power levels for plant {} detected'.format(num_indices, i))

p[i].append(value)
\end{python}

\subsection{Adjusting Power Levels}
\label{implementation:quantum.read.solution}

The program translates the optimal solution of the DQM or QUBO to a solution for the UCP.
This solution, however, is not legal.
The sum of the power outputs at every time instance does not satisfy the demand.
The program, therefore, raises the power outputs of all plants at every time instance uniformly.
While doing so, it also avoids violating the power limits of the individual plants.
Listing \ref{implementation:quantum.read.solution.algorithm} shows the code that adjusts the power levels.

\begin{python}[
  float,
  caption={Adjusting the UCP Solution},
  label={implementation:quantum.read.solution.algorithm}
]
for t in range(self.ucp.parameters.num_loads):
  # set adjust bool for every power plant that is active
  adjust: List[bool] = [self.u[i][t] for i in range(self.ucp.parameters.num_plants)]
  # compute the power that is missing or too much
  delta: float = self.ucp.loads[t] - sum([self.p[i][t] for i in range(self.ucp.parameters.num_plants)])

  while True:
    if delta == 0 or not functools.reduce(lambda a,b: a or b, adjust):
      # repeat the loop until either the demand is met (delta == 0)
      # or no plant can be adjusted anymore
      break

    adjustment: float = delta / sum([1 if b else 0 for b in adjust])
    delta = 0

    for i in range(self.ucp.parameters.num_plants):
      if adjust[i]:
        # add a portion of the delta to every power output
        self.p[i][t] += adjustment
        Pmax: float = self.ucp.plants[i].Pmax
        Pmin: float = self.ucp.plants[i].Pmin

        # if the power output violates the limits of the power plant
        # set it to the limit and add the difference to the delta again
        if self.p[i][t] > Pmax:
          delta += self.p[i][t] - Pmax
          self.p[i][t] = Pmax
          adjust[i] = False

        elif self.p[i][t] < Pmin:
          delta += self.p[i][t] - Pmin
          self.p[i][t] = Pmin
          adjust[i] = False
\end{python}
