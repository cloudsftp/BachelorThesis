\subsection{Implementation of QUBO for Annealing Hardware}
\label{implementation:annealing.qubo}

For the implementation of the QUBO for the annealing-based hardware, this work uses the UQO-client~\cite{UQOPyPI, UQOGitHub}.
First, it writes the biases into a python \texttt{dict}.
Then the class \texttt{Qubo} of the UQO-client builds the \texttt{dwave-ocean-sdk} \texttt{BinaryQuadraticModel}-instance that the UQO-client can then send to the UQO-server.

\subsubsection{Variables}
\label{implementation:annealing.qubo.variables}

The variables in this implementation are implicit.
The indices for the python \texttt{dict} are pairs of integers where the integers are the IDs of the variables.
Each ID is computed with the mapping function $m'$ of the formula (\ref{formula:qubo.mapping}).

\subsubsection{Quadratic Biases}
\label{implementation:annealing.qubo.quadratic}

In this case, there are $3$ types of quadratic biases --- biases resulting from either
\begin{enumerate*}[label=(\roman*)]
  \item Startup and Shutdown costs, or
  \item Demand constraints, or
  \item Discretization constraints.
\end{enumerate*}

The startup and shutdown costs are different for every power plant but do not change over time.
The program iterates over all power plants $i$ and times $t > 0$ and applies the startup and shutdown costs.
The program iterates over every power output value index $0 \leq k < 2^{n_i}$ for the power plant $i$.
It adds the quadratic bias $A_U$ for the pair $(p_{i, t-1, 0}, p_{i, t, k})$ and the quadratic bias for the pair $(p_{i, t-1, k}, p_{i, t, 0})$

The demand constraints are different for every plant pair but do not change over time, like the startup and shutdown costs.
The program iterates over all pairs of power plants $(i, j)$ where $i < j$ and power output value indices $0 \leq k < 2^{n_i}$ and $0 \leq l < 2^{n_j}$.
Then it iterates over all times $t$ and applies the quadratic constraint $\gamma_d P_{i, k} * P_{j, l}$ to the pair $(p_{i, t, k}, p_{j, t, l})$
The quadratic constraint is only computed once for every pair of power plants $(i, j)$ and pair of power output values $(k, l)$.

The discretization constraint is the same for every plant and time instance.
The program iterates over all power plants $i$ and times $t$.
Then it iterates over all pairs of power output value indices $(k, l)$ where $0 \leq k < 2^{n_i}, 0 \leq l < 2^{n_j}$ and $k < l$ and aplies the quadratic constraint $\gamma_d$ to the pair $(p_{i, t, k}, p_{i, t, l})$.

The quadratic biases do not overlap.
The demand constraint biases and startup and shutdown biases are on orthogonal axes as mentioned in section \ref{implementation:annealing.dqm.quadratic}.
The biases constraining the power levels per power plant --- only one power level $k$ per power plant $i$ and time instance $t$ may be chosen --- are between different power levels $0 \leq k < 2^{n_i}, 0 \leq l < 2^{n_i}$ with $k \neq l$ of the same power plant at the same time instance $t$.
Therefore they don't interfere with the demand constraint biases since they are between different power levels $0 \leq k < 2^{n_i}, 0 \leq l < 2^{n_j}$ of different power plants $i, j$.

\subsubsection{Linear Biases}
\label{implementation:annealing.qubo.linear}

The linear biases depend on the fuel cost and the demand constraints.
That's why they change for every plant $i$, every time instance $t$, and every possible power level $k$.
Just as with the implementation of the DQM in section \ref{implementation:annealing.dqm.linear}, the linear biases of variables of the form $p_{i, 0, k}$ depend on the startup and shutdown costs and the initial state of the power plant $i$.
The formula (\ref{formula:qubo.result.linear}) captures the computation of the linear biases.

The program iterates over all power plants $i$, times $t$, and possible power levels $0 \leq k < 2^{n_i}$.
It calculates the linear bias as specified in formula (\ref{formula:qubo.result.linear}) for all indices.
Then it applies the linear bias to the variable $p_{i, t, k}$.

As mentioned in section \ref{implementation:annealing.qubo}, the program first builds the QUBO as a Python \texttt{dict}.
The keys are pairs of integers $(i, j)$ with $i \neq j$ for quadratic biases.
For linear biases, the keys are pairs with identical integers $(i, i)$.

\subsubsection{Constant Bias}
\label{implementation:annealing.qubo.constant}

The constant bias is defined by the formula (\ref{formula:qubo.result.constant}).
Because the constant bias does not change the optimal input value, the implementation ignores it.
