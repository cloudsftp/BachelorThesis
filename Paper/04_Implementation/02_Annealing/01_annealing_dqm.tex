\subsection{Implementation of DQM for Annealing Hardware}
\label{implementation:annealing.dqm}

For the implementation of the DQM for annealing-based hardware, this work uses D-Wave's \texttt{dwave-ocean-sdk}~\cite{OceanSDKDoc}.
To be more specific, it uses the class \texttt{DiscreteQuadraticModel} that is part of the \texttt{dimod} package~\cite{DQMDoc}.
The source code of the SDK is available online~\cite{OceanSDKGit}.

\subsubsection{Variables}

The first step is to instantiate a DQM with discrete variables.
One discrete variable is added to the model for every $p_{i, t}$ of the DQM defined in section \ref{approach:annealing.formulate}.
The size of the discrete variable $p_{i, t}$ --- the number of possible values --- is $| P_i |$.

\subsubsection{Quadratic Biases}
\label{implementation:annealing.dqm.quadratic}

There are $2$ types of quadratic biases --- biases resulting from either
\begin{enumerate*}[label=(\roman*)]
  \item Startup and shutdown costs, or
  \item Demand constraints.
\end{enumerate*}

The startup and shutdown biases are different for every plant but do not change over time.
The program computes them once for every plant.
Then it applies them to variables that correspond to the same plant but correspond to adjacent time instances.
So $S_i$ is computed and then applied to variables $p_{i, t-1}$ and $p_{i, t}$ for all $t > 0$.
Listing \ref{implementation:annealing.dqm.quadratic.startup.code} shows the code implementing these quadratic biases.

\begin{python}[
  float,
  caption={Implementation of the Quadratic Startup and Shutdown Biases for DQMs},
  label={implementation:annealing.dqm.quadratic.startup.code}
]
def set_quadratic_startup(self, y_s: float) -> None:
  '''
  sets the quadratic biases for the startup costs for the DQM
  '''
  for i in range(self.ucp.parameters.num_plants):
    # compute once for every plant i
    plant: CombustionPlant = self.ucp.plants[i]
    num_cases: int = len(self.P[i])
    quadratic_biases: np.ndarray = np.zeros((num_cases, num_cases))

    for k in range(1, num_cases):
      quadratic_biases[0, k] = plant.AU
      quadratic_biases[k, 0] = plant.AD

    quadratic_biases *= y_s

    for t in range(1, self.ucp.parameters.num_loads):
      # apply for one plant i at every time t > 0
      self.model.set_quadratic(self.p[i][t-1], self.p[i][t], quadratic_biases)
\end{python}

The demand biases are different for every pair of plants involved but do not change over time.
The program computes them once for every pair of plants.
Then it applies them to the variables that correspond to the same time $t$ but correspond to each one of the involved plants.
So $P_i \otimes P_j$ is computed and then applied to the variables $p_{i, t}$ and $p_{j, t}$ for all $i < j$.
Listing \ref{implementation:annealing.dqm.quadratic.demand.code} shows the code implementing these quadratic biases.

\begin{python}[
  float,
  caption={Implementation of the Quadratic Demand Biases for DQMs},
  label={implementation:annealing.dqm.quadratic.demand.code}
]
def set_quadratic_demand(self, y_d: float) -> None:
  '''
  sets the quadratic biases for the demand for the DQM
  '''
  for j in range(1, self.ucp.parameters.num_plants):
    for i in range(j):
      # compute once for every pair of plants i, j (i < j)
      quadratic_biases: np.ndarray = np.tensordot(self.P[i], self.P[j], axes=0)
      quadratic_biases *= y_d

      for t in range(self.ucp.parameters.num_loads):
        # apply for one pair of plants i, j at every time t
        self.model.set_quadratic(self.p[i][t], self.p[j][t], quadratic_biases)
\end{python}

The two categories of quadratic biases do not overlap.
This is because the startup and shutdown biases are applied along the time axes, and the demand biases are applied along the plant axes, which is orthogonal to the time axes.

\subsubsection{Linear Biases}
\label{implementation:annealing.dqm.linear}

The linear biases are different for every plant and every time instance.
They depend on the fuel cost, the possible power levels, and the demand at that time instance.
If the variable is of the form $p_{i, 0}$ --- meaning it corresponds to the first time instance --- the linear bias of that variable is also dependent on the startup or shutdown costs and the initial state of the plant.
The formula (\ref{formula:dqm.result.linear}) captures the computation of the linear biases.

The program iterates over all power plants $i$ and time instances $t$.
It calculates the linear bias as specified in the formula (\ref{formula:dqm.result.linear}) for all indices.
Then it applies the calculated linear bias to the variable $p_{i, t}$.
Listing \ref{implementation:annealing.dqm.linear.code} shows the code implementing these linear biases.

\begin{python}[
  float,
  caption={Implementation of the Linear Biases for DQMs},
  label={implementation:annealing.dqm.linear.code}
]
  def set_linear(self, y_c: float, y_s: float, y_d: float) -> None:
    '''
    sets the linear biases for the DQM
    '''
    for i in range(len(self.p)):
      P_i: np.ndarray = self.P[i]
      plant: CombustionPlant = self.ucp.plants[i]
      F_i: np.ndarray = self.calculate_F_i(plant, i)

      for t in range(len(self.p[i])):
        linear_biases: np.ndarray = y_c * F_i + y_d * (
          P_i * P_i - self.ucp.loads[t] * P_i
        ) # implements formula for linear biases of the report

        if t == 0: # if t is 0, add initial startup or shutdown costs
          if plant.initially_on:
            linear_biases[0] += y_s * plant.AD

          else:
            for k in range(1, len(linear_biases)):
              linear_biases[k] += y_s * plant.AU

        self.model.set_linear(self.p[i][t], linear_biases)
\end{python}

\subsubsection{Constant Bias}

The constant bias is defined by the fromula (\ref{formula:dqm.result.constant}).
The class \texttt{DiscreteQuadraticModel} does not have an interface for adding a constant bias.
Because a constant bias does not change the optimal input value, the implementation ignores it.
