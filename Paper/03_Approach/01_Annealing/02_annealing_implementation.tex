\section{Implementation for Annealing-based Quantum Computers}

The implementation of the DQM uses D-Waves \texttt{dwave-ocean-sdk}.
\cite{OceanSDKDoc}
To be more specific, it uses the class \texttt{DiscreteQuadraticModel} that is part of the \texttt{dimod} package.
\cite{DQMDoc}
The source code of the SDK is available online.
\cite{OceanSDKGit}

\subsection*{Variables}

The first step is to instantiate a DQM with discrete variables.
One discrete variable is added to the model for every $p_{i, t}$ of the DQM defined in section \ref{approach:annealing.formulate}.
The size of the discrete variable $p_{i, t}$ --- the number of possible values --- is $| P_i |$.

\subsection*{Quadratic Biases}

There are two types of quadratic biases.
One category is the startup and shutdown biases, and the other is the biases resulting from the demand constraints.

The startup and shutdown biases are different for every plant but do not change over time.
The program computes them once for every plant.
Then it applies them to variables that correspond to the same plant but correspond to adjacent time instances.
So $S_i$ is computed and then applied to variables $p_{i, t-1}$ and $p_{i, t}$ for all $t > 0$.

The demand biases are different for every pair of plants targeted by the bias but do not change over time.
The program computes them once for every pair of plants.
Then it applies them to the variables that correspond to the same time instance but correspond to each one of the targeted plants.
So $P_i \otimes P_j$ is computed and then applied to the variables $p_{i, t}$ and $p_{j, t}$ for all $i < j$.

The two categories of quadratic biases do not overlap.
This is because the startup and shutdown biases are applied along the time axes,
and the demand biases are applied along the plant axes, which is orthogonal to the time axes.

\subsection*{Linear Biases}

The linear biases are different for every plant and every time instance.
They depend on the fuel cost, the possible power levels, and the demand at that time instance.
If the variable is of the form $p_{i, 0}$ --- meaning it corresponds to the first time instance --- the linear bias of that variable is also dependent on the startup or shutdown costs and the initial state of the plant.
The formula (\ref{formula:dqm.result.linear}) captures the computation of the linear biases.

The program iterates over all discrete variables $p_{i, t}$.
For every variable it calculates the linear bias as specified in formula (\ref{formula:dqm.result.linear}).
Then it applies the calculated linear bias to the variable $p_{i, t}$.

\subsection*{Constant Bias}

The constant bias is defined by the fromula (\ref{formula:dqm.result.constant}).
The class \texttt{DiscreteQuadraticModel} does not have an interface for adding a constant bias.
Because a constant bias does not change the optimal input value, the implementation ignores it.

\subsection{Adjusting Solution}
\label{approach:annealing.implementation.adjust}

The program translates the optimal solution of the DQM to a solution for the UCP.
This solution, however, is not legal.
The sum of the power outputs at every time instance does not satisfy the demand.
The program, therefore, raises the power outputs of all plants at every time instance uniformly.
While doing so, it also avoids violating the power limits of the individual plants.
For this the algortihm \ref{approach:annealing.implementation.adjust.algorithm} is used.

\todo{Replace with final code}

\begin{lstlisting}[
  caption={Adjusting the UCP Solution},
  label={approach:annealing.implementation.adjust.algorithm},
  language=Python
]
for t in range(self.ucp.parameters.num_loads):
  adjust: List[bool] = [u[i][t] for i in range(self.ucp.parameters.num_plants)]
  delta: float = self.ucp.loads[t] - sum([p[i][t] for i in range(self.ucp.parameters.num_plants)])

  while True:
    if delta == 0 or not functools.reduce(lambda a,b: a or b, adjust):
      break

    adjustment: float = delta / sum([1 if b else 0 for b in adjust])
    delta = 0

    for i in range(self.ucp.parameters.num_plants):
      if adjust[i]:
        p[i][t] += adjustment
        Pmax: float = self.ucp.plants[i].Pmax
        Pmin: float = self.ucp.plants[i].Pmin

        if p[i][t] > Pmax:
          delta += p[i][t] - Pmax
          p[i][t] = Pmax
          adjust[i] = False

        elif p[i][t] < Pmin:
          delta += p[i][t] - Pmin
          p[i][t] = Pmin
          adjust[i] = False
\end{lstlisting}
